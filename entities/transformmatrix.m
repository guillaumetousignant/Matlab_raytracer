classdef transformmatrix < handle
    % Tranformation matrix class.
    % Constructor can be:   - Empty (creates an identity matrix)
    %                       - Another transformation matrix (will copy)
    %                       - A 4-by-4 matrix of doubles
    %                       - 16 numbers representing the members of the matrix. Sent line by line.
    %
    % Functions:
    %       - rotate(vec, angle)
    %               Takes a vector (no need to be normalized) around which to rotate by angle.

properties
    matrix
end

methods
    function obj = transformmatrix(varargin)
        obj = obj@handle();
        
        if isempty(varargin)
            obj.matrix = eye(4, 4);
        elseif isa(varargin{1}, 'transformmatrix')
            obj.matrix = varargin{1}.matrix;
        elseif isa(varargin{1}, 'double') && all(size(varargin{1}) == [4, 4])
            obj.matrix = varargin{1};
        elseif length(varargin) == 16
            obj.matrix = [  varargin{1}, varargin{2}, varargin{3}, varargin{4}; ...
                            varargin{5}, varargin{6}, varargin{7}, varargin{8}; ...
                            varargin{9}, varargin{10}, varargin{11}, varargin{12}; ...
                            varargin{13}, varargin{14}, varargin{15}, varargin{16}];
        else
            warning('raytracer:transformmatrix:badInput', 'Wrong input, identity created.')
            obj.matrix = eye(4, 4);
        end
    end

    function rotatexaxis(obj, angle)
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, cos(angle), sin(angle), 0; ...
                                    0, -sin(angle), cos(angle), 0; ...
                                    0, 0, 0, 1];
    end

    function rotateyaxis(obj, angle)
        obj.matrix = obj.matrix * [ cos(angle), 0, -sin(angle), 0; ...
                                    0, 1, 0, 0; ...
                                    sin(angle), 0, cos(angle), 0; ...
                                    0, 0, 0, 1];
    end

    function rotatezaxis(obj, angle)
        obj.matrix = obj.matrix * [ cos(angle), sin(angle), 0, 0; ...
                                    -sin(angle), cos(angle), 0, 0; ...
                                    0, 0, 1, 0; ...
                                    0, 0, 0, 1];
    end

    function rotatex(obj, angle) % maybe slow, inline the translation, maybe find the the matrix and not do the multiplication
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    -obj.matrix(4, 1:3), 1] ...
                                * [ 1, 0, 0, 0; ...
                                    0, cos(angle), sin(angle), 0; ...
                                    0, -sin(angle), cos(angle), 0; ...
                                    0, 0, 0, 1] ...
                                * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    obj.matrix(4, 1:3), 1];
    end

    function rotatey(obj, angle) % maybe slow, inline the translation, maybe find the the matrix and not do the multiplication
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    -obj.matrix(4, 1:3), 1] ...
                                * [ cos(angle), 0, -sin(angle), 0; ...
                                    0, 1, 0, 0; ...
                                    sin(angle), 0, cos(angle), 0; ...
                                    0, 0, 0, 1] ...
                                * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    obj.matrix(4, 1:3), 1];
    end

    function rotatez(obj, angle) % maybe slow, inline the translation, maybe find the the matrix and not do the multiplication
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    -obj.matrix(4, 1:3), 1] ...
                                * [ cos(angle), sin(angle), 0, 0; ...
                                    -sin(angle), cos(angle), 0, 0; ...
                                    0, 0, 1, 0; ...
                                    0, 0, 0, 1] ...
                                * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    obj.matrix(4, 1:3), 1];
    end

    function rotateaxis(obj, vec, angle) % might need to transpose the 3x3 part
        vec = vec/norm(vec);
        obj.matrix = obj.matrix * [ vec(1) * vec(1) * (1 - cos(angle)) + cos(angle), vec(2) * vec(1) * (1 - cos(angle)) - vec(3) * sin(angle), vec(3) * vec(1) * (1 - cos(angle)) + vec(2) * sin(angle), 0; ...
                                    vec(1) * vec(2) * (1 - cos(angle)) + vec(3) * sin(angle), vec(2) * vec(2) * (1 - cos(angle)) + cos(angle), vec(3) * vec(2) * (1 - cos(angle)) - vec(1) * sin(angle), 0; ...
                                    vec(1) * vec(3) * (1 - cos(angle)) - vec(1) * sin(angle), vec(1) * vec(2) * (1 - cos(angle)) + vec(1) * sin(angle), vec(3) * vec(3) * (1 - cos(angle)) + cos(angle), 0; ...
                                    0, 0, 0, 1];
    end

    function rotate(obj, vec, angle) % maybe slow, inline the translation, maybe find the the matrix and not do the multiplication
        vec = vec/norm(vec);         % Might need to transpose the 3x3 part
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    -obj.matrix(4, 1:3), 1] ...
                                * [ vec(1) * vec(1) * (1 - cos(angle)) + cos(angle), vec(2) * vec(1) * (1 - cos(angle)) - vec(3) * sin(angle), vec(3) * vec(1) * (1 - cos(angle)) + vec(2) * sin(angle), 0; ...
                                    vec(1) * vec(2) * (1 - cos(angle)) + vec(3) * sin(angle), vec(2) * vec(2) * (1 - cos(angle)) + cos(angle), vec(3) * vec(2) * (1 - cos(angle)) - vec(1) * sin(angle), 0; ...
                                    vec(1) * vec(3) * (1 - cos(angle)) - vec(1) * sin(angle), vec(1) * vec(2) * (1 - cos(angle)) + vec(1) * sin(angle), vec(3) * vec(3) * (1 - cos(angle)) + cos(angle), 0; ...
                                    0, 0, 0, 1] ...
                                * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    obj.matrix(4, 1:3), 1];
    end

    function translate(obj, vec)
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    vec(1), vec(2), vec(3), 1];
    end

    function scaleaxis(obj, vec)
        obj.matrix = obj.matrix * [ vec(1), 0, 0, 0; ...
                                    0, vec(2), 0, 0; ...
                                    0, 0, vec(3), 0; ...
                                    0, 0, 0, 1];
    end

    function uniformscaleaxis(obj, fac)
        obj.matrix = obj.matrix * [ fac, 0, 0, 0; ...
                                    0, fac, 0, 0; ...
                                    0, 0, fac, 0; ...
                                    0, 0, 0, 1];
    end

    function scale(obj, vec)
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    -obj.matrix(4, 1:3), 1] ...
                                * [ vec(1), 0, 0, 0; ...
                                    0, vec(2), 0, 0; ...
                                    0, 0, vec(3), 0; ...
                                    0, 0, 0, 1] ...
                                * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    obj.matrix(4, 1:3), 1];
    end

    function uniformscale(obj, fac)
        obj.matrix = obj.matrix * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    -obj.matrix(4, 1:3), 1] ...
                                * [ fac, 0, 0, 0; ...
                                    0, fac, 0, 0; ...
                                    0, 0, fac, 0; ...
                                    0, 0, 0, 1] ...
                                * [ 1, 0, 0, 0; ...
                                    0, 1, 0, 0; ...
                                    0, 0, 1, 0; ...
                                    obj.matrix(4, 1:3), 1];
    end

    function reflect(obj, vec) % not sure, vec must have 4 components, the 4th being the distance between the vector and the origin I think
        % Also might need to swap obj.matrix and constructed matrix
        % or probably juste transpose constructed matrix.
        obj.matrix = obj.matrix * [ 1 - 2 * vec(1) * vec(1), -2 * vec(1) * vec(2), -2 * vec(1) * vec(3), -2 * vec(1) * vec(4); ...
                                    -2 * vec(1) * vec(2), 1 - 2 * vec(2) * vec(2), -2 * vec(2) * vec(3), -2 * vec(2) * vec(4); ...
                                    -2 * vec(1) * vec(3), -2 * vec(2) * vec(3), 1 - 2 * vec(3) * vec(3), -2 * vec(3) * vec(4); ...
                                    0, 0, 0, 1];
    end

    function shear(obj, vec)
        % [1 a b 0
        %  c 1 d 0
        %  e f 1 0
        %  0 0 0 1]
    end

    function transpose(obj)
        obj.matrix = obj.matrix';
    end

    function invert(obj)
        obj.matrix = inv(obj.matrix);
    end

    function neg(obj)
        obj.matrix = -obj.matrix;
    end

    function out = multVec(obj, vec) % for points
        out = [vec, 1] * obj.matrix; % change to ones(size(vec, 1), 1)?
        out = out(1:3)/out(4);
    end

    function out = multDir(obj, dir) % for normals % not sure about that one
        out = dir * obj.matrix(1:3, :);
        out = out(1:3);
        out = out / norm(out); % really not sure about this
    end

    function [transform_norm] = transformDir(obj)
        transform_norm = transformmatrix(obj);
        transform_norm.invert;
        transform_norm.transpose;
    end
end
end